#!/usr/bin/env python
# -*- coding: utf-8 -*-
import argparse
import json
from masappci import mASAPP_CI

ASCII_ART_DESCRIPTION = U'''
                        _____           _____   _____      _____  _____ 
                /\     / ____|   /\    |  __ \ |  __ \    / ____||_   _|
  _ __ ___     /  \   | (___    /  \   | |__) || |__) |  | |       | |  
 | '_ ` _ \   / /\ \   \___ \  / /\ \  |  ___/ |  ___/   | |       | |  
 | | | | | | / ____ \  ____) |/ ____ \ | |     | |       | |____  _| |_ 
 |_| |_| |_|/_/    \_\|_____//_/    \_\|_|     |_|        \_____||_____|

'''


def main():
    """

    **Riskscoring execution**

        It would analyse the given app throwing an error only if the risk is greater than the given
        with the param -r. This operation can not being thrown simultaneously with standard execution.

        Usage example:
        ::
            masappci -r float -a path/to/the/app.ipa (or apk) [-p packageNameOrigin] [-d]

    **Standard execution:**

        It would analyse the given app throwing an error if there are more vulnerabilities or behaviors
        than the given in the in the json file. This operation can not being thrown simultaneously with riskscoring execution.

        Usage example
        ::
            masappci -s path/to/vulns_and_behaviors.json -a path/to/the/app.ipa (or apk) [-p packageNameOrigin] [-d]


    **Additional params**

        * PackageNameOrigin: The packageNameOrigin is an unequivocally value generated by mASAPP for identifying the \
        applications. Giving this param you would help to the script to find your application in your user's \
        scans if you don't use this param, the script would look into the user scans using the name of your \
        .apk or .ipa file but sometimes it doesn't find because of a different interpretation of this field by mASAPP \
        or an error generating this field. If the script doesn't find your app will show a list of all the scans that \
        your user has, asking you to find your application and to execute it again using the param -p with the \
        correct packageNameOrigin. \

        * Detailed execution: If the user use this param, the following information will be shown after a successful\
        execution:

            * A list of vulnerabilities, adding the tittle, risk, number of occurrences and the different occurrences\
            with their evidences.

            * A list of behaviors, adding the tittle, number of occurrences, impact and the different occurrences\
            with their evidences.


    """
    parser = argparse.ArgumentParser(prog='masappci', description=ASCII_ART_DESCRIPTION,
                                     formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument('-a', '--app', help='path to the .apk or .ipa file', metavar=".ipa/.apk",
                        required=True)
    parser.add_argument('-p', '--packageNameOrigin', help='package name origin of the app')
    parser.add_argument('-r', '--riskscore', help='riskscoring execution', type=float, metavar="N")
    parser.add_argument('-d', '--detailed', help='add details to the execution', action='store_true')
    parser.add_argument('-s', '--standard', help='standard execution', metavar=".json")

    args = parser.parse_args()

    if args.riskscore and args.standard:
        print("Riskscore and standard execution can not being thrown simultaneously")
        parser.print_help()
        return False

    elif args.riskscore:
        user = mASAPP_CI(key="", secret="")
        if args.packageNameOrigin:
            user.riskscoring_execution(maximum_riskscoring=args.riskscore, app_path=args.app,
                                       package_name_origin=args.packageNameOrigin,
                                       detail=args.detailed)
        else:
            user.riskscoring_execution(maximum_riskscoring=args.riskscore, app_path=args.app, detail=args.detailed)


    else:
        def check_json(input_json):
            if ".json" in input_json:
                try:
                    input_json = json.load(open(input_json))
                except:
                    parser.print_help()
                    return False
                correct_json = input_json['vulnerabilities'] != None or input_json['behaviorals']

                if not correct_json:
                    parser.print_help()
                    return False
                else:
                    return input_json

            parser.print_help()
            return False

        if args.standard:
            checked_json = check_json(args.standard)
            if checked_json:
                user = mASAPP_CI(key="", secret="")

                if type(checked_json) != bool:
                    if args.packageNameOrigin:
                        user.standard_execution(scan_maximum_values=checked_json, app_path=args.app,
                                                package_name_origin=args.packageNameOrigin,
                                                detail=args.detailed)

                    else:
                        user.standard_execution(scan_maximum_values=checked_json, app_path=args.app,
                                                detail=args.detailed)
            else:
                print(
                    u"""
                        -s --standard json structure:
                            {
                              "vulnerabilities": {
                                "critical": maximum of critical vulnerabilities,
                                "high": maximum of high vulnerabilities,
                                "medium": maximum of medium vulnerabilities,
                                "low": maximum of low vulnerabilities
                              },
                              "behaviorals": {
                                "critical": maximum of critical behaviorals,
                                "high": "maximum of high behaviorals,
                                "medium": maximum of medium behavioral,
                                "low": maximum of low behaviorals
                              }
                            }     
                    """
                )


        else:
            parser.print_help()


if __name__ == "__main__":
    main()
